// GENERATED FILE - DO NOT EDIT
// Generated by tool/gen_a64_db.dart

import '../core/labels.dart';
import 'a64.dart';
import 'a64_assembler.dart';
import 'a64_inst_db.g.dart';

/// Dispatches A64 instruction IDs to assembler methods for the supported set.
void a64Dispatch(A64Assembler asm, int instId, List<Object> ops) {
  switch (instId) {
    case A64InstId.kAbs:
      _vec2(asm, ops, (rd, rn) => asm.abs(rd, rn));
      break;
    case A64InstId.kAdd:
      _add(asm, ops);
      break;
    case A64InstId.kAdds:
      _adds(asm, ops);
      break;
    case A64InstId.kAdr:
      _adr(asm, ops);
      break;
    case A64InstId.kAdrp:
      _adrp(asm, ops);
      break;
    case A64InstId.kAnd:
      _and(asm, ops);
      break;
    case A64InstId.kAsr:
      _shift(asm, ops, A64Shift.asr);
      break;
    case A64InstId.kB:
      _b(asm, ops);
      break;
    case A64InstId.kBic:
      _vec3(asm, ops, (rd, rn, rm) => asm.bic(rd, rn, rm));
      break;
    case A64InstId.kBif:
      _vec3(asm, ops, (rd, rn, rm) => asm.bif(rd, rn, rm));
      break;
    case A64InstId.kBit:
      _vec3(asm, ops, (rd, rn, rm) => asm.bit(rd, rn, rm));
      break;
    case A64InstId.kBl:
      _bl(asm, ops);
      break;
    case A64InstId.kBlr:
      _blr(asm, ops);
      break;
    case A64InstId.kBr:
      _br(asm, ops);
      break;
    case A64InstId.kBrk:
      if (ops.length == 1 && ops[0] is int) asm.brk(ops[0] as int);
      break;
    case A64InstId.kBsl:
      _vec3(asm, ops, (rd, rn, rm) => asm.bsl(rd, rn, rm));
      break;
    case A64InstId.kCbnz:
      _cb(asm, ops, zero: false);
      break;
    case A64InstId.kCbz:
      _cb(asm, ops, zero: true);
      break;
    case A64InstId.kCls:
      _vec2(asm, ops, (rd, rn) => asm.cls(rd, rn));
      break;
    case A64InstId.kClz:
      _vec2(asm, ops, (rd, rn) => asm.clz(rd, rn));
      break;
    case A64InstId.kCmn:
      _cmn(asm, ops);
      break;
    case A64InstId.kCmp:
      _cmp(asm, ops);
      break;
    case A64InstId.kCnt:
      _vec2(asm, ops, (rd, rn) => asm.cnt(rd, rn));
      break;
    case A64InstId.kDup:
      _dup(asm, ops);
      break;
    case A64InstId.kEor:
      _eor(asm, ops);
      break;
    case A64InstId.kFabs:
      _vec2(asm, ops, (rd, rn) => asm.fabs(rd, rn));
      break;
    case A64InstId.kFadd:
      _vec3(asm, ops, (rd, rn, rm) => asm.fadd(rd, rn, rm));
      break;
    case A64InstId.kFaddp:
      _vec3(asm, ops, (rd, rn, rm) => asm.faddp(rd, rn, rm));
      break;
    case A64InstId.kFcmp:
      _vec2(asm, ops, (rn, rm) => asm.fcmp(rn, rm));
      break;
    case A64InstId.kFcsel:
      _fcsel(asm, ops);
      break;
    case A64InstId.kFdiv:
      _vec3(asm, ops, (rd, rn, rm) => asm.fdiv(rd, rn, rm));
      break;
    case A64InstId.kFmax:
      _vec3(asm, ops, (rd, rn, rm) => asm.fmaxVec(rd, rn, rm));
      break;
    case A64InstId.kFmaxnm:
      _vec3(asm, ops, (rd, rn, rm) => asm.fmaxnmVec(rd, rn, rm));
      break;
    case A64InstId.kFmin:
      _vec3(asm, ops, (rd, rn, rm) => asm.fminVec(rd, rn, rm));
      break;
    case A64InstId.kFminnm:
      _vec3(asm, ops, (rd, rn, rm) => asm.fminnmVec(rd, rn, rm));
      break;
    case A64InstId.kFmul:
      _vec3(asm, ops, (rd, rn, rm) => asm.fmul(rd, rn, rm));
      break;
    case A64InstId.kFneg:
      _vec2(asm, ops, (rd, rn) => asm.fneg(rd, rn));
      break;
    case A64InstId.kFsqrt:
      _vec2(asm, ops, (rd, rn) => asm.fsqrt(rd, rn));
      break;
    case A64InstId.kFsub:
      _vec3(asm, ops, (rd, rn, rm) => asm.fsub(rd, rn, rm));
      break;
    case A64InstId.kLdp:
      _ldp(asm, ops);
      break;
    case A64InstId.kLdr:
      _ldr(asm, ops);
      break;
    case A64InstId.kLdrb:
      _ldrb(asm, ops);
      break;
    case A64InstId.kLdrh:
      _ldrh(asm, ops);
      break;
    case A64InstId.kLdrsb:
      _ldrsb(asm, ops);
      break;
    case A64InstId.kLdrsh:
      _ldrsh(asm, ops);
      break;
    case A64InstId.kLdrsw:
      _ldrsw(asm, ops);
      break;
    case A64InstId.kLsl:
      _shift(asm, ops, A64Shift.lsl);
      break;
    case A64InstId.kLsr:
      _shift(asm, ops, A64Shift.lsr);
      break;
    case A64InstId.kMadd:
      _madd(asm, ops);
      break;
    case A64InstId.kMov:
      _mov(asm, ops);
      break;
    case A64InstId.kMovk:
      _movk(asm, ops);
      break;
    case A64InstId.kMovn:
      _movn(asm, ops);
      break;
    case A64InstId.kMovz:
      _movz(asm, ops);
      break;
    case A64InstId.kMsub:
      _msub(asm, ops);
      break;
    case A64InstId.kMul:
      _mul(asm, ops);
      break;
    case A64InstId.kMvn:
      _vec2(asm, ops, (rd, rn) => asm.mvn(rd, rn));
      break;
    case A64InstId.kNeg:
      _vec2(asm, ops, (rd, rn) => asm.neg(rd, rn));
      break;
    case A64InstId.kNop:
      if (ops.isEmpty) asm.nop();
      break;
    case A64InstId.kOrn:
      _vec3(asm, ops, (rd, rn, rm) => asm.orn(rd, rn, rm));
      break;
    case A64InstId.kOrr:
      _orr(asm, ops);
      break;
    case A64InstId.kRet:
      _ret(asm, ops);
      break;
    case A64InstId.kRev16:
      _vec2(asm, ops, (rd, rn) => asm.rev16(rd, rn));
      break;
    case A64InstId.kRev32:
      _vec2(asm, ops, (rd, rn) => asm.rev32(rd, rn));
      break;
    case A64InstId.kRev64:
      _vec2(asm, ops, (rd, rn) => asm.rev64(rd, rn));
      break;
    case A64InstId.kSdiv:
      _ternaryReg(asm, ops, (rd, rn, rm) => asm.sdiv(rd, rn, rm));
      break;
    case A64InstId.kSmov:
      _smov(asm, ops);
      break;
    case A64InstId.kStp:
      _stp(asm, ops);
      break;
    case A64InstId.kStr:
      _str(asm, ops);
      break;
    case A64InstId.kStrb:
      _strb(asm, ops);
      break;
    case A64InstId.kStrh:
      _strh(asm, ops);
      break;
    case A64InstId.kSub:
      _sub(asm, ops);
      break;
    case A64InstId.kSubs:
      _subs(asm, ops);
      break;
    case A64InstId.kSvc:
      if (ops.length == 1 && ops[0] is int) asm.svc(ops[0] as int);
      break;
    case A64InstId.kUdiv:
      _ternaryReg(asm, ops, (rd, rn, rm) => asm.udiv(rd, rn, rm));
      break;
    case A64InstId.kUmov:
      _umov(asm, ops);
      break;
    default:
      break;
  }
}

void _add(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is A64Gp) {
    asm.add(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp);
  } else if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec) {
    asm.addVec(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec);
  } else if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.addImm(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _adds(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.addsImm(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _sub(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is A64Gp) {
    asm.sub(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp);
  } else if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec) {
    asm.subVec(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec);
  } else if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.subImm(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _subs(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.subsImm(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _and(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is A64Gp) {
    asm.and(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp);
  } else if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec) {
    asm.andVec(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec);
  }
}

void _orr(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is A64Gp) {
    asm.orr(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp);
  } else if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec) {
    asm.orrVec(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec);
  }
}

void _eor(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is A64Gp) {
    asm.eor(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp);
  } else if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec) {
    asm.eorVec(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec);
  }
}

void _shift(A64Assembler asm, List<Object> ops, A64Shift shift) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    final dst = ops[0] as A64Gp;
    final src = ops[1] as A64Gp;
    final imm = ops[2] as int;
    final zr = dst.is64Bit ? xzr : wzr;
    if (shift == A64Shift.lsl) {
      asm.orr(dst, zr, src, shift: shift, amount: imm);
    } else {
      asm.eor(dst, zr, src, shift: shift, amount: imm);
    }
  }
}

void _cmp(A64Assembler asm, List<Object> ops) {
  if (ops.length == 2 && ops[0] is A64Gp && ops[1] is A64Gp) {
    asm.cmp(ops[0] as A64Gp, ops[1] as A64Gp);
  } else if (ops.length == 2 && ops[0] is A64Gp && ops[1] is int) {
    asm.cmpImm(ops[0] as A64Gp, ops[1] as int);
  }
}

void _cmn(A64Assembler asm, List<Object> ops) {
  if (ops.length == 2 && ops[0] is A64Gp && ops[1] is int) {
    asm.cmnImm(ops[0] as A64Gp, ops[1] as int);
  }
}

void _mov(A64Assembler asm, List<Object> ops) {
  if (ops.length == 2 && ops[0] is A64Gp && ops[1] is int) {
    asm.movImm64(ops[0] as A64Gp, ops[1] as int);
  }
}

void _movz(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is int && ops[2] is int) {
    asm.movz(ops[0] as A64Gp, ops[1] as int, shift: ops[2] as int);
  }
}

void _movn(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is int && ops[2] is int) {
    asm.movn(ops[0] as A64Gp, ops[1] as int, shift: ops[2] as int);
  }
}

void _movk(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is int && ops[2] is int) {
    asm.movk(ops[0] as A64Gp, ops[1] as int, shift: ops[2] as int);
  }
}

void _adr(A64Assembler asm, List<Object> ops) {
  if (ops.length == 2 && ops[0] is A64Gp && ops[1] is int) {
    asm.adr(ops[0] as A64Gp, ops[1] as int);
  }
}

void _adrp(A64Assembler asm, List<Object> ops) {
  if (ops.length == 2 && ops[0] is A64Gp && ops[1] is int) {
    asm.adrp(ops[0] as A64Gp, ops[1] as int);
  }
}

void _b(A64Assembler asm, List<Object> ops) {
  if (ops.length == 1 && ops[0] is Label) {
    asm.b(ops[0] as Label);
  }
}

void _bl(A64Assembler asm, List<Object> ops) {
  if (ops.length == 1 && ops[0] is Label) {
    asm.bl(ops[0] as Label);
  }
}

void _cb(A64Assembler asm, List<Object> ops, {required bool zero}) {
  if (ops.length != 2) return;
  final rt = ops[0];
  final lbl = ops[1];
  if (rt is A64Gp && lbl is Label) {
    if (zero) {
      asm.cbz(rt, lbl);
    } else {
      asm.cbnz(rt, lbl);
    }
  }
}

void _br(A64Assembler asm, List<Object> ops) {
  if (ops.length == 1 && ops[0] is A64Gp) {
    asm.br(ops[0] as A64Gp);
  }
}

void _blr(A64Assembler asm, List<Object> ops) {
  if (ops.length == 1 && ops[0] is A64Gp) {
    asm.blr(ops[0] as A64Gp);
  }
}

void _ret(A64Assembler asm, List<Object> ops) {
  if (ops.isEmpty) {
    asm.ret();
  } else if (ops.length == 1 && ops[0] is A64Gp) {
    asm.ret(ops[0] as A64Gp);
  }
}

void _ldr(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[1] is A64Gp && ops[2] is int) {
    final base = ops[1] as A64Gp;
    final off = ops[2] as int;
    if (ops[0] is A64Gp) {
      asm.ldr(ops[0] as A64Gp, base, off);
    } else if (ops[0] is A64Vec) {
      asm.ldrVec(ops[0] as A64Vec, base, off);
    }
  }
}

void _str(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[1] is A64Gp && ops[2] is int) {
    final base = ops[1] as A64Gp;
    final off = ops[2] as int;
    if (ops[0] is A64Gp) {
      asm.str(ops[0] as A64Gp, base, off);
    } else if (ops[0] is A64Vec) {
      asm.strVec(ops[0] as A64Vec, base, off);
    }
  }
}

void _ldrb(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.ldrb(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _ldrh(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.ldrh(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _ldrsb(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.ldrsb(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _ldrsh(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.ldrsh(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _ldrsw(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.ldrsw(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _strb(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.strb(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _strh(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is int) {
    asm.strh(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as int);
  }
}

void _ldp(A64Assembler asm, List<Object> ops) {
  if (ops.length == 4 &&
      ops[0] is A64Gp &&
      ops[1] is A64Gp &&
      ops[2] is A64Gp &&
      ops[3] is int) {
    asm.ldp(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp, ops[3] as int);
  }
}

void _stp(A64Assembler asm, List<Object> ops) {
  if (ops.length == 4 &&
      ops[0] is A64Gp &&
      ops[1] is A64Gp &&
      ops[2] is A64Gp &&
      ops[3] is int) {
    asm.stp(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp, ops[3] as int);
  }
}

void _ternaryReg(A64Assembler asm, List<Object> ops,
    void Function(A64Gp, A64Gp, A64Gp) fn) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is A64Gp) {
    fn(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp);
  }
}

void _mul(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Gp && ops[2] is A64Gp) {
    asm.mul(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp);
  } else if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec) {
    asm.mulVec(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec);
  }
}

void _madd(A64Assembler asm, List<Object> ops) {
  if (ops.length == 4 &&
      ops[0] is A64Gp &&
      ops[1] is A64Gp &&
      ops[2] is A64Gp &&
      ops[3] is A64Gp) {
    asm.madd(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp, ops[3] as A64Gp);
  }
}

void _msub(A64Assembler asm, List<Object> ops) {
  if (ops.length == 4 &&
      ops[0] is A64Gp &&
      ops[1] is A64Gp &&
      ops[2] is A64Gp &&
      ops[3] is A64Gp) {
    asm.msub(ops[0] as A64Gp, ops[1] as A64Gp, ops[2] as A64Gp, ops[3] as A64Gp);
  }
}

void _vec3(A64Assembler asm, List<Object> ops,
    void Function(A64Vec, A64Vec, A64Vec) fn) {
  if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec) {
    fn(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec);
  }
}

void _vec2(A64Assembler asm, List<Object> ops,
    void Function(A64Vec, A64Vec) fn) {
  if (ops.length == 2 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec) {
    fn(ops[0] as A64Vec, ops[1] as A64Vec);
  }
}

void _fcsel(A64Assembler asm, List<Object> ops) {
  if (ops.length == 4 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is A64Vec &&
      ops[3] is A64Cond) {
    asm.fcsel(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as A64Vec, ops[3] as A64Cond);
  }
}

void _dup(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 &&
      ops[0] is A64Vec &&
      ops[1] is A64Vec &&
      ops[2] is int) {
    asm.dup(ops[0] as A64Vec, ops[1] as A64Vec, ops[2] as int);
  }
}

void _umov(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Vec && ops[2] is int) {
      asm.umov(ops[0] as A64Gp, ops[1] as A64Vec, ops[2] as int);
  }
}

void _smov(A64Assembler asm, List<Object> ops) {
  if (ops.length == 3 && ops[0] is A64Gp && ops[1] is A64Vec && ops[2] is int) {
      asm.smov(ops[0] as A64Gp, ops[1] as A64Vec, ops[2] as int);
  }
}


