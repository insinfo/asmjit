// GENERATED FILE - DO NOT EDIT
// Generated by tool/gen_x86_db.dart

import 'x86_assembler.dart';
import 'x86_inst_db.g.dart';
import 'x86.dart';
import 'x86_operands.dart';
import 'x86_encoder.dart' show X86Cond;
import 'x86_simd.dart';
import '../core/labels.dart';

/// Dispatches instruction ID to Assembler method for implemented ops.
/// Unsupported IDs are ignored (no-op), keeping behavior compatible with older stubs.
void x86Dispatch(X86Assembler asm, int instId, List<Object> ops) {
  switch (instId) {
    case X86InstId.kAdd:
      _binary(asm, ops, (a, b) => asm.addRR(a, b), (a, imm) => asm.addRI(a, imm));
      break;
    case X86InstId.kAddpd:
      _simd3(asm, ops, xmm: (d, s1, s2) => asm.vaddpdXXX(d, s1, s2), ymm: (d, s1, s2) => asm.vaddpdYYY(d, s1, s2), zmm: (d, s1, s2) => asm.vaddpdZmm(d, s1, s2));
      break;
    case X86InstId.kAddps:
      _simd3(asm, ops, xmm: (d, s1, s2) => asm.vaddpsXXX(d, s1, s2), ymm: (d, s1, s2) => asm.vaddpsYYY(d, s1, s2), zmm: (d, s1, s2) => asm.vaddpsZmm(d, s1, s2));
      break;
    case X86InstId.kAnd:
      _binary(asm, ops, (a, b) => asm.andRR(a, b), (a, imm) => asm.andRI(a, imm));
      break;
    case X86InstId.kCall:
      _call(asm, ops);
      break;
    case X86InstId.kCdq:
      asm.cdq();
      break;
    case X86InstId.kCmovb:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovbe:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovl:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovle:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovnb:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovnbe:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovnl:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovnle:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovno:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovnp:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovns:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovnz:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovo:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovp:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovs:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmovz:
      _cmovcc(asm, instId, ops);
      break;
    case X86InstId.kCmp:
      _binary(asm, ops, (a, b) => asm.cmpRR(a, b), (a, imm) => asm.cmpRI(a, imm));
      break;
    case X86InstId.kCqo:
      asm.cqo();
      break;
    case X86InstId.kDec:
      _unary(asm, ops, (r) => asm.dec(r));
      break;
    case X86InstId.kDiv:
      _unary(asm, ops, (r) => asm.div(r));
      break;
    case X86InstId.kIdiv:
      _unary(asm, ops, (r) => asm.idiv(r));
      break;
    case X86InstId.kImul:
      _imul(asm, ops);
      break;
    case X86InstId.kInc:
      _unary(asm, ops, (r) => asm.inc(r));
      break;
    case X86InstId.kJb:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJbe:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJl:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJle:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJmp:
      _jmp(asm, ops);
      break;
    case X86InstId.kJnb:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJnbe:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJnl:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJnle:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJno:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJnp:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJns:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJnz:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJo:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJp:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJs:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kJz:
      _jcc(asm, instId, ops);
      break;
    case X86InstId.kLea:
      if (ops.length == 2 && ops[0] is X86Gp && ops[1] is X86Mem) asm.lea(ops[0] as X86Gp, ops[1] as X86Mem);
      break;
    case X86InstId.kMov:
      _mov(asm, ops);
      break;
    case X86InstId.kMul:
      _unary(asm, ops, (r) => asm.mul(r));
      break;
    case X86InstId.kNeg:
      _unary(asm, ops, (r) => asm.neg(r));
      break;
    case X86InstId.kNot:
      _unary(asm, ops, (r) => asm.not(r));
      break;
    case X86InstId.kOr:
      _binary(asm, ops, (a, b) => asm.orRR(a, b), (a, imm) => asm.orRI(a, imm));
      break;
    case X86InstId.kPop:
      _pop(asm, ops);
      break;
    case X86InstId.kPush:
      _push(asm, ops);
      break;
    case X86InstId.kRet:
      _ret(asm, ops);
      break;
    case X86InstId.kRol:
      _shift(asm, ops, (r, imm) => asm.rolRI(r, imm), null);
      break;
    case X86InstId.kRor:
      _shift(asm, ops, (r, imm) => asm.rorRI(r, imm), null);
      break;
    case X86InstId.kSar:
      _shift(asm, ops, (r, imm) => asm.sarRI(r, imm), (r) => asm.sarRCl(r));
      break;
    case X86InstId.kSetb:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetbe:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetl:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetle:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetnb:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetnbe:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetnl:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetnle:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetno:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetnp:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetns:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetnz:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSeto:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetp:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSets:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kSetz:
      _setcc(asm, instId, ops);
      break;
    case X86InstId.kShl:
      _shift(asm, ops, (r, imm) => asm.shlRI(r, imm), (r) => asm.shlRCl(r));
      break;
    case X86InstId.kShr:
      _shift(asm, ops, (r, imm) => asm.shrRI(r, imm), (r) => asm.shrRCl(r));
      break;
    case X86InstId.kSub:
      _binary(asm, ops, (a, b) => asm.subRR(a, b), (a, imm) => asm.subRI(a, imm));
      break;
    case X86InstId.kTest:
      _binary(asm, ops, (a, b) => asm.testRR(a, b), (a, imm) => asm.testRI(a, imm));
      break;
    case X86InstId.kVpandd:
      _simd3(asm, ops, zmm: (d, s1, s2) => asm.vpanddZmm(d, s1, s2));
      break;
    case X86InstId.kVpandq:
      _simd3(asm, ops, zmm: (d, s1, s2) => asm.vpandqZmm(d, s1, s2));
      break;
    case X86InstId.kVpord:
      _simd3(asm, ops, zmm: (d, s1, s2) => asm.vpordZmm(d, s1, s2));
      break;
    case X86InstId.kVporq:
      _simd3(asm, ops, zmm: (d, s1, s2) => asm.vporqZmm(d, s1, s2));
      break;
    case X86InstId.kVpxord:
      _simd3(asm, ops, zmm: (d, s1, s2) => asm.vpxordZmm(d, s1, s2));
      break;
    case X86InstId.kVpxorq:
      _simd3(asm, ops, zmm: (d, s1, s2) => asm.vpxorqZmm(d, s1, s2));
      break;
    case X86InstId.kVxorpd:
      _simd3(asm, ops, zmm: (d, s1, s2) => asm.vxorpdZmm(d, s1, s2));
      break;
    case X86InstId.kVxorps:
      _simd3(asm, ops, xmm: (d, s1, s2) => asm.vxorpsXXX(d, s1, s2), ymm: (d, s1, s2) => asm.vxorpsYYY(d, s1, s2), zmm: (d, s1, s2) => asm.vxorpsZmm(d, s1, s2));
      break;
    case X86InstId.kXor:
      _binary(asm, ops, (a, b) => asm.xorRR(a, b), (a, imm) => asm.xorRI(a, imm));
      break;
    default:
      break;
  }
}

// Helpers
void _mov(X86Assembler asm, List<Object> ops) {
  if (ops.length != 2) return;
  final dst = ops[0];
  final src = ops[1];
  if (dst is X86Gp && src is X86Gp) {
    asm.movRR(dst, src);
  } else if (dst is X86Gp && src is int) {
    asm.movRI64(dst, src);
  } else if (dst is X86Gp && src is X86Mem) {
    asm.movRM(dst, src);
  } else if (dst is X86Mem && src is X86Gp) {
    asm.movMR(dst, src);
  }
}

void _binary(X86Assembler asm, List<Object> ops,
    void Function(X86Gp, X86Gp) rr, void Function(X86Gp, int) ri) {
  if (ops.length != 2) return;
  final dst = ops[0];
  final src = ops[1];
  if (dst is X86Gp && src is X86Gp) {
    rr(dst, src);
  } else if (dst is X86Gp && src is int) {
    ri(dst, src);
  }
}

void _unary(X86Assembler asm, List<Object> ops, void Function(X86Gp) r) {
  if (ops.length == 1 && ops[0] is X86Gp) r(ops[0] as X86Gp);
}

void _shift(X86Assembler asm, List<Object> ops,
    void Function(X86Gp, int) ri, void Function(X86Gp)? rCl) {
  if (ops.length != 2) return;
  final dst = ops[0];
  final src = ops[1];
  if (dst is X86Gp && src is int) {
    ri(dst, src);
  } else if (dst is X86Gp && src is X86Gp && src.id == 1 && rCl != null) {
    rCl(dst);
  }
}

void _imul(X86Assembler asm, List<Object> ops) {
  if (ops.length == 2) {
    final dst = ops[0];
    final src = ops[1];
    if (dst is X86Gp && src is X86Gp) {
      asm.imulRR(dst, src);
    } else if (dst is X86Gp && src is int) {
      asm.imulRI(dst, src);
    }
  } else if (ops.length == 3) {
    final dst = ops[0];
    final src = ops[1];
    final imm = ops[2];
    if (dst is X86Gp && src is X86Gp && imm is int) {
      asm.imulRRI(dst, src, imm);
    }
  }
}

void _push(X86Assembler asm, List<Object> ops) {
  if (ops.length != 1) return;
  final op = ops[0];
  if (op is X86Gp) {
    asm.push(op);
  } else if (op is int) {
    asm.pushImm32(op);
  }
}

void _pop(X86Assembler asm, List<Object> ops) {
  if (ops.length == 1 && ops[0] is X86Gp) {
    asm.pop(ops[0] as X86Gp);
  }
}

void _jmp(X86Assembler asm, List<Object> ops) {
  if (ops.length != 1) return;
  final op = ops[0];
  if (op is Label) {
    asm.jmp(op);
  } else if (op is X86Gp) {
    asm.jmpR(op);
  } else if (op is int) {
    asm.jmpRel(op);
  }
}

void _call(X86Assembler asm, List<Object> ops) {
  if (ops.length != 1) return;
  final op = ops[0];
  if (op is Label) {
    asm.call(op);
  } else if (op is X86Gp) {
    asm.callR(op);
  } else if (op is int) {
    asm.callRel(op);
  }
}

void _ret(X86Assembler asm, List<Object> ops) {
  if (ops.isEmpty) {
    asm.ret();
  } else if (ops.length == 1 && ops[0] is int) {
    asm.retImm(ops[0] as int);
  }
}

void _jcc(X86Assembler asm, int instId, List<Object> ops) {
  if (ops.isEmpty) return;
  final cond = _condFromInst(instId);
  if (cond == null) return;
  final op = ops[0];
  if (op is Label) {
    asm.jcc(cond, op);
  } else if (op is int) {
    asm.jccRel(cond, op);
  }
}

void _setcc(X86Assembler asm, int instId, List<Object> ops) {
  if (ops.length == 1 && ops[0] is X86Gp) {
    final cond = _condFromInst(instId);
    if (cond != null) asm.setcc(cond, ops[0] as X86Gp);
  }
}

void _cmovcc(X86Assembler asm, int instId, List<Object> ops) {
  if (ops.length == 2 && ops[0] is X86Gp && ops[1] is X86Gp) {
    final cond = _condFromInst(instId);
    if (cond != null) asm.cmovcc(cond, ops[0] as X86Gp, ops[1] as X86Gp);
  }
}

X86Cond? _condFromInst(int instId) {
  switch (instId) {
    case X86InstId.kJo:
    case X86InstId.kSeto:
    case X86InstId.kCmovo:
      return X86Cond.o;
    case X86InstId.kJno:
    case X86InstId.kSetno:
    case X86InstId.kCmovno:
      return X86Cond.no;
    case X86InstId.kJb:
    case X86InstId.kSetb:
    case X86InstId.kCmovb:
      return X86Cond.b;
    case X86InstId.kJnb:
    case X86InstId.kSetnb:
    case X86InstId.kCmovnb:
      return X86Cond.nb;
    case X86InstId.kJz:
    case X86InstId.kSetz:
    case X86InstId.kCmovz:
      return X86Cond.e;
    case X86InstId.kJnz:
    case X86InstId.kSetnz:
    case X86InstId.kCmovnz:
      return X86Cond.ne;
    case X86InstId.kJbe:
    case X86InstId.kSetbe:
    case X86InstId.kCmovbe:
      return X86Cond.be;
    case X86InstId.kJnbe:
    case X86InstId.kSetnbe:
    case X86InstId.kCmovnbe:
      return X86Cond.a;
    case X86InstId.kJs:
    case X86InstId.kSets:
    case X86InstId.kCmovs:
      return X86Cond.s;
    case X86InstId.kJns:
    case X86InstId.kSetns:
    case X86InstId.kCmovns:
      return X86Cond.ns;
    case X86InstId.kJp:
    case X86InstId.kSetp:
    case X86InstId.kCmovp:
      return X86Cond.p;
    case X86InstId.kJnp:
    case X86InstId.kSetnp:
    case X86InstId.kCmovnp:
      return X86Cond.np;
    case X86InstId.kJl:
    case X86InstId.kSetl:
    case X86InstId.kCmovl:
      return X86Cond.l;
    case X86InstId.kJnl:
    case X86InstId.kSetnl:
    case X86InstId.kCmovnl:
      return X86Cond.ge;
    case X86InstId.kJle:
    case X86InstId.kSetle:
    case X86InstId.kCmovle:
      return X86Cond.le;
    case X86InstId.kJnle:
    case X86InstId.kSetnle:
    case X86InstId.kCmovnle:
      return X86Cond.g;
    default:
      return null;
  }
}

void _simd3(
  X86Assembler asm,
  List<Object> ops, {
  void Function(X86Xmm, X86Xmm, X86Xmm)? xmm,
  void Function(X86Ymm, X86Ymm, X86Ymm)? ymm,
  void Function(X86Zmm, X86Zmm, X86Zmm)? zmm,
}) {
  if (ops.length != 3) return;
  final dst = ops[0];
  final s1 = ops[1];
  final s2 = ops[2];

  if (zmm != null && dst is X86Zmm && s1 is X86Zmm && s2 is X86Zmm) {
    zmm(dst, s1, s2);
    return;
  }
  if (ymm != null && dst is X86Ymm && s1 is X86Ymm && s2 is X86Ymm) {
    ymm(dst, s1, s2);
    return;
  }
  if (xmm != null && dst is X86Xmm && s1 is X86Xmm && s2 is X86Xmm) {
    xmm(dst, s1, s2);
  }
}

